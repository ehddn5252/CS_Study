# 프로세스(Process) 란??

운영체제로 부터 자원을 할당받은 **작업의 단위**이다.

- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원(독립된 메모리 영역)을 할당 받는 작업의 단위
- 동적인 개념으로는 컴퓨터에서 실행되고 있는 프로그램을 의미

프로세스는 각각 독립된 메모리영역 (Code, Data, Stack, Heap 의 구조)을 할당 받는다.

스택,힙 - 동적영역 / 데이터,코드 - 정적영역

- 스택 : 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정되며 동적인 특징을 갖는다
- 힙 : 동적할당할때 사용되며 , 런타임 시 크기가 결정된다
- 데이터 : 전역변수, 정적변수가 저장되고, 정적인 특징을 갖는 프로그램이 종료되면 사라지는 변수가 들어있다
- 코드 : 프로그램에 내장되어 있는 소스코드가 들어간다

## 프로세스 상태

- New (생성) : 프로세스가 생성된 상태
- Ready(준비) : 프로세스가 처리기를 사용하고 있지는 않지만 언제든 사용할 수 있는 상태를 의미
  - 프로세스가 처리기의 배정을 기다리고 있는 상태
  - 다른 프로세스 실행을 위해서 일시적으로 정지해있는 상태
  - CPU에 의해 처리되기 위해 주기억 장치에 존재하는 상태
- Running (실행) : 프로세스가 CPU를 차지하고 있는 상태 또는 프로세스의 명령이 실행되고 있는 상태
- Block (Wait, 대기/보류) : 프로세스가 어떤 사건이 일어나기 기다리는 상태
  - 처리속도가 느린 I/O 작업중인 상태
  - 외부적인 사건이 생길때까지 실행할 수 없는 상태
- Blocked Suspended : 프로세스가 대기 상태에서 기억장치를 잃은 상태
- Suspended Ready : 프로세스가 기억장치를 제외한 다른 모든 필요한 자원을 보유한 상태
- Exit(Terminated) : 프로세스의 실행을 완료하고 할당된 CPU를 반납한 상태

## 프로세스 상태변화

- Dispatch (준비 → 실행) : 준비상태에 있는 여러 프로세스 중 프로세스를 선정하여 CPU를 할당하는 시점
- Timer Run Out ( 할당시간 종료, 실행 → 준비) : 할당된 시간만큼 CPU를 사용하고 준비 상태로 변하는 시점
- I/O 발생(Block, 실행→대기) : 프로세스가 CPU 사용중에 I/O 행위가 필요하여 대기상태로 이동하는 시점
- Wake up (대기→준비) : I/O작업이 완료되거나 자원이 할당되어 다시 준비 상태로 이동하는 시점
- Suspended(Swap-Out, 대기→ 지연준비) : 준비/대기 상태에서 기억장치를 반납하고 지연준비상태로 전이
- Resume(Swap-In, 지연준비→ 대기) : 지연 준비/지연 대기 상태에서 기억장치를 할당받아 준비(대기)상태로 전이

<img width="950" alt="Untitled" src="https://user-images.githubusercontent.com/87989933/174754285-b73c3633-bc98-4f55-b737-0f6fbe1a2dc4.png">

<br/>

# **PCB(Process Control Block)**

프로그램이 실행되면 프로세스가 생성되고, 이 프로세스의 정보(메타데이터)를 저장하고 관리하는 곳으로, 프로세스 제어 블록이라고 한다.

## PCB의 구조

- 프로세스 ID (Process ID) - 프로세스 고유번호
- 프로세스 상태 (Process State) - 준비,대기,실행등의 상태
- 프로그램 계수기 (Program Counter) - 다음 실행될 명령어의 주소에 대한 포인터
- 프로세스 권한
- CPU 레지스터 - 프로세스 실행을 위한 레지스터 정보
- CPU 스케줄링 정보
- 프로세스 계정 정보 - CPU사용량, 실행한 유저정보
- I/O 상태 정보 - 할당된 I/O 디바이스 목록

# **Context Switching**

PCB를 교환하는 과정을 말한다

한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.

컴퓨터가 많은 프로그램을 동시에 실행하는것처럼 보이지만, 어떤 시점에 하나의 코어에서 실행되고 있는 프로세스는 단 한개이며, 동시에 실행되는 것 처럼 보이는것은 컨텍스트 스위칭이 아주 빠르게 실행되기 때문이다.

## 작동순서

![Untitled (1)](https://user-images.githubusercontent.com/87989933/174754271-1340c0ed-a5ce-4fff-848b-b531c283eb49.png)

프로세스 A가 running 상태이고, 프로세스 B가 ready 상태일때,

1. 스케줄러가 A의 실행을 중단하고 B 실행을 요청
2. A에서 Stack의 데이터 위치를 가리키고 있는 포인터와 다음 실행해야하는 코드 주소값을 가진 Program Counter의 값을 PCB에 저장한다
3. A는 ready 또는 block 상태로 바뀌고, CPU에서 B를 실행한다. 이때 프로세스 B의 상태가 ready에서 running으로 바뀐다 (dispatch)

하나의 프로세스가 실행하다 멈추고, 그 프로세스의 PCB를 저장하고, 다른 프로세스를 로드하여 실행한다.
이렇게 컨텍스트 스위칭이 일어날때 유휴시간(idle time)이 발생한다. 추가로 캐시미스도 발생한다

\* 캐시미스  
컨텍스트 스위칭이 일어날때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소변환이 생기므로, 캐시클리어 과정을 겪게 되고 이로인해 캐시미스가 발생한다

\* 스레드에서의 컨텍스트 스위칭  
스레드는 스택영역을 제외한 모든 메모리를 공유하기 때문에, 스레드 컨텍스트 스위칭은 비용이 더 적고 시간도 적게 걸린다

<br/>

## 참고

[https://velog.io/@codemcd/운영체제OS-5.-프로세스-관리](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC)
[https://many258.github.io/study/os-process/](https://many258.github.io/study/os-process/)

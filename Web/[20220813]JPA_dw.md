# JPA

<details>

<summary span style="font-size:20px">1. JAP Basic</summary>


# JPA basic

```java
package jpabook.start;

import javax.persistance.*;

@Emtity
@Table(name="MEMBER")
public class Member{

    @Id
    @Column(name = "ID")
    private String id;

    @Column(name = "NAME")
    private String username;

    // 매핑 정보가 없는 필드
    private Integer age;
    ...
}
```

![KakaoTalk_20220726_192008675](https://user-images.githubusercontent.com/51036842/180983623-c14738c8-4cc8-49ea-815b-a434ad9837ed.jpg)

## @Entity
- 이 클래스를 테이블과 매핑한다고 JPA 에게 알려준다.
- 이렇게 @Entity가 사용된 클래스를 엔티티 클래스라 한다.

## @Table
- 엔티티 클래스에 매핑할 테이블 정보를 알려준다. 여기서는 name 속성을 사용해서 Member 엔티티를 MEMBER 테이블에 매핑했다. 이 어노테이션을 생략하면 클래스 이름을 테이블 이름으로 매핑한다.

## @Id
- 에닡티 클래스의 필드를 테이블의 기본 키(PK)에 매핑한다. 여기서는 엔티티의 id 필드를 테이블의 ID 기본 키 컬럼에 매핑했다. 이렇게 @ID가 사용된 필드를 식별자 필드라 한다.

## @Column
- 필드를 컬럼에 매핑한다. 여기서는 name 속성을 사용해서 Member 엔티티의 username 필드를 MEMBEr 테이블의 NAME 컬럼에 매핑했다.

## 매핑 정보가 없는 필드
- AGE 필드에는 매핑 어노테이션이 없다. 이렇게 매핑 어노테이션을 생략하면 필드명을 사용해서 컬럼명을 매핑한다. 여기서는 필드명이 AGE이므로 AGE 컬럼으로 매핑했다. 참고로 대소문자를 구분하는 데이터베이스를 사용한다고 하면 명시적으로 매핑해야 한다.

|JPA 어노테이션의 패키지는 javax.persistence 이다.

## 어플리케이션 개발
```java
package jpabook.start;

import javax.persistence.*;
import java.util.List;

public class JpaMain{

    public static void main(String[] args){

        // [엔티티 매니저 팩토리] - 생성
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
        //[엔티티 매니저] - 생성
        EntityManager em = emf.createEntityManager();

        // [트랜잭션] - 획득
        EntityTransaction tx = em.getTransaction();

        try{

            tx.begin(); //[트랜잭션] - 시작
            login(em); // 비즈니스 로직 실행
            tx.commit(); //[트랜잭션] - 커밋

        } catch(Exception e){
            tx.rollback(); //[트랜잭션] - 롤백
        } finally {
            em.close(); //[엔티티 매니저 팩토리] - 종료
        } // [엔티티 매니저 팩토리] - 종료
        emf.close();
    }
    
    // 비즈니스 로직
    private static void logic(EntityManager em){
        ...
    }
}
```

코드는 크게 3부분으로 나뉘어 있다.
- 엔티티 매니저 설정
- 트랜잭션 관리
- 비즈니스 로직

### 2.6.1 에닡티 매니저 설정
엔티티 매니저의 생성 과정은 다음과 같다.

 ![KakaoTalk_20220726_192008675](https://user-images.githubusercontent.com/51036842/180988838-66b82b21-809d-4e87-b8ff-0a27fbb9d17e.jpg)

- 엔티티 매니저 팩토리 생성
- JPA를 시작하려면 우선 persistence.xml의 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야 한다. 이때 Persistence 클래스를 사용하는데, 이 클래스는 엔티티 매니저 팩토리를 생성해서 JPA를 사용할 수 있게 준비한다.

```java
EntityManagerFactory emf = Peresistence.createEntityManagerfactory("jpabook");
```

이렇게 하면 META-INF/persistence.xml에서 이름이 jpabook 인 영속성 유닛 persistence-unit을 찾아서 엔티티 매니저 팩토리를 생성한다.

 이때 persistence.xml의 설정 정보를 읽어서 JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스 커넥션 풀도 생성하므로 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다.
 
  따라서 <span style="color:yellow">엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야 한다.
</span>

엔티티 매니저 팩토리를 만들었으니 이제 엔티티 매니저를 생성하자.

## 엔티티 매니저 생성
```java
EntityManager em = emf.createEntityManager();
```
엔티티 매니저 팩토리에서 엔티티 매니저를 생성한다. JPA의 기능 대부분은 이 엔티티 매니저가 제공한다. <span style="color:yellow"> 대표적으로 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록/수정/삭제/조회할 수 있다.</span> 엔티티 매니저는 내부에 데이터소스(데이터베이스 커넥션)를 유지하면서 데이터베이스와 통신한다. 따라서 애플리케이션 개발자는 엔티티 매니저를 가상의 데이터베이스로 생각할 수 있다.
- 참고로 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용하면 안 된다.

## 종료
마지막으로 사용이 끝난 매니저는 다음처럼 반드시 종료해야 한다.
```java
em.close(); //엔티티 매니저 종료
```

```java
emf.close(); //엔티티 매니저 팩토리 종료
```

## 2.6.2 트랜잭션 관리
- JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다. 트랜잭션을 시작하려면 엔티티 매니저(em) 에서 트랜잭션 API를 받아와야 한다. 

```java
EntityTransaction tx = em.getTransaction(); // 트랜잭션 API
try{

    tx.begin(); // 트랜잭션 시작
    logic(em);  //비즈니스 로직 실행
    tx.commit(); //트랜잭션 커밋
}catch(Exception e){
    tx.rollback(); // 예외 발생 시 트랜잭션 롤백
}
```
- 트랜잭션을 시작하고 비즈니스 로직이 정상 동작하면 커밋하고 예외가 생기면 롤백을 한다.

## 2.6.3 비즈니스 로직
비즈니스 로직은 단순하다. 예제 2.10 을 보면 회원 엔티티를 하나 생성한 다음 엔티티 매니저를 통해 데이터베이스에 등록, 수정, 삭제, 조회를 한다.

```java
public static void logic(EntityManager em){
    String id = "id1";
    Member member = new Member();
    member.setId(id);
    member.setUsername("지한");
    member.setAge(2);

    // 등록
    em.persist(member);

    // 수정
    member.setAge(20);

    // 한 건 조회
    Member findMember = em.find(Member.class, id);
    System.out.println("findMember=" + findMember.getUsername() + ". age=" + findMember.getAge());

    // 목록 조회
    List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();
    System.out.println("members.size=" + members.size());

    // 삭제
    em.remove(member);
}
```
출력 결과는 다음과 같다.

findMember = 지한, age = 20
members.size=1

비즈니스 로직을 보면 등록, 수정, 삭제, 조회 작업이 엔티티 매니저em 를 통해서 수행되는 것을 알 수 있다. 엔티티 매니저는 객체를 저장하는 가상의 데이터베이스처럼 보인다. 먼저 등록, 수정, 삭제 코드를 분석해보자.

### 등록
```java
String id = "id1";
Member member = new Member();
member.setId(id);
member.setUsername("지한");
member.setAge(2);
```
엔티티를 저장하려면 엔티티 매니저의 persist() 메소드에 저장할 엔티티를 넘겨주면 된다. 예제를 보면 회원 엔티티를 생성하고 em.persist(member) 를 실행해서 엔티티를 저장했다. JPA는 회원 엔티티의 매핑 정보(어노테이션)를 분석해서 다음과 같은 SQL을 만들어 데이터베이스에 전달한다.
```SQL
INSERT INTO MEMBER (ID, NAME, AGE) VALUES('id1','지한',2)
```
### 수정
```java
//수정
member.setAge(20);
```
수정 부분을 보면 조금 이상하다. 엔티티를 수정한 후에 수정 내용을 반영하려면 em.update() 같은 메소드를 호출해야 할 것 같은데 단순히 엔티티의 값만 변경했다. JAP는 어떤 엔티티가 변경되었는지 추적하는 기능을 갖추고 있다. <span style="color:yellow">따라서 member.setAge(20)처럼 엔티티의 값만 변경하면 다음과 같은 UPDATE SQL을 생성해서 데이터베이스에 값을 변경한다.</span> 사실 em.update()라는 메소드도 없다.

```java
UPDATE MEMBER
    SET AGE=20, NAME='지한'
WHERE ID='id1'
```

### 삭제
```java
em.remove(member);
```
엔티티를 삭제하려면 엔티티 매니저의 remove() 메소드에 삭제하려는 엔티티를 넘겨준다. JPA는 다음 DELETE SQL을 생성해서 실행한다.
```SQL
DELETE  FROM MEMBER WHERE ID = 'id1'
```

### 한 건 조회
```java
// 한 건 조회
Member findMember = em.find(Member.class,id);
```
find() 메소드는 조회할 엔티티 타입과 @Id로 데이터베이스 테이블의 기본 키와 매핑한 식별자 값으로 엔티티 하나를 조회하는 가장 단순한 조회 메소드다. 이 메소드를 호출하면 다음 SELECT SQL을 생성해서 데이터베이스에 결과를 조회한다. 그리고 조회한 결과 값으로 엔티티를 생성해서 반환한다.


## 참고 자료
- 자바 ORM 표준 JPA 프로그래밍:스프링 데이터 예제 프로젝트로 배우는 전자정부 표준 데이터베이스 프레임 - 김영한
- https://gmlwjd9405.github.io/2019/08/12/primary-key-mapping.html

</details>


<details>

<summary span style="font-size:20px">2. JPQL</summary>


# 2.6.4 JPQL
하나 이상의 회원 목록을 조회하는 다음 코드를 자세히 살펴보자.
```JAVA
//목록 조회
TypedQuery<Member> query = em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```

- JPA를 사용하면 애플리케이션 개발자는 엔티티 객체를 중심으로 개발하고 데이터베이스에 대한 처리는 JPA에 맡겨야 한다. 
- 바로 앞에서 살펴본 등록, 수정, 삭제, 한 건 조회 예를 보면 SQL을 전혀 사용하지 않았다. 문제는 검색 쿼리다. 
- <span style="color:yellow">JPA는 엔티티 객체를 중심으로 개발하므로 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색해야 한다.</span>
- 그런데 테이블이 아닌 엔티티 객체를 대상으로 검색하려면 데이터베이스의 모든 데이터를 애플리케이션으로 불러와서 엔티티 객체로 변경한 다음 검색해야 하는데, 이는 사실상 불가능하다. 애플리케이션이 필요한 데이터만 데이터베이스에서 불러오려면 결국 검색 조건이 포함된 SQL을 사용해야 한다. JPA는 JPQL(Java Persistence Query Language)이라는 쿼리 언어로 이런 문제를 해결한다.

 JPA는 SQL을 추상화한 JPQL이라는 객체지향 쿼리 언어를 제공한다. JPQL은 SQL과 문법이 거의 유사해서 SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 등을 사용할 수 있다. 둘의 가장 큰 차이점은 다음과 같다.

 - <span style="font-size:18px"> JPQL은 엔티티 객체를 대상으로 쿼리한다. </SPAN>쉽게 이야기해서 클래스와 필드를 대상으로 쿼리한다.
 - <span style="font-size:18px">SQL은 데이터베이스 테이블을 대상으로 쿼리한다.</SPAN>

방금 본 목록 조회 예제에서 select m from Member m 이 바로 JPQL이다. 여기에서 from Member는 회원 엔티티 객체를 말하는 것이지 MEMBER 테이블이 아니다.<span style="color:yellow"> JPQL은 데이터베이스 테이블을 전혀 알지 못한다. </span>

JPQL을 사용하려면 먼저 em.createQuery(JPQL, 반환 타입) 메소드를 실행해서 쿼리 객체를 생성한 후 쿼리 객체의 getResultList() 메소드를 호출하면 된다.
JPA는 JPQL을 분석해서 다음과 같은 적절한 SQL을 만들어 데이터베이스에서 데이터를 조회한다.
```SQL
SELECT M.ID, M.NAME, M.AGE FROM MEMBER M
```
| JPQL은 대소문자를 명확하게 구분하지만 SQL은 관례상 대소문자를 구분하지 않고 사용하는 경우가 많다. 
</details>

<details>


<summary span style="font-size:20px">4. table mapping</summary>


# 4.0 개요
JPA를 사용하는 데 가장 중요한 일은 엔티티와 테이블을 정확하게 매핑하는 것이다. 따라서 매핑 어노테이션을 숙지하고 사용해야 한다.

JPA는 다양한 매핑 어노테이션을 지원하는데 크게 가지로 분류할 수 있다.
- 객체와 테이블 매핑: @Entity, @Table
- 기본 키 매핑: @Id
- 필드와 컬럼 매핑: @Column
- 연관관계 매핑: @ManyToOne, @JoinColumn


# 4.1 @Entity
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션을 필수로 붙여야 한다. @Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라 부른다.

|속성|기능|기본값|
|--|--|--|
|name|JPA에서 사용할 엔티티 이름을 지정한다. 보통 기본값인 클래스 이름을 사용한다. 만약 다른 패키지에 이름이 같은 엔티티 클래스가 있다면 이름을 지정해서 충돌하지 않도록 해야 한다.|설정하지 않으면 클래스이름을 그대로 사용한다(예: Member).|

## 주의사항
- 기본 생성자는 필수다(파라미터가 없는 public 또는 protected 생성자)
- final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.
- 저장할 필드에 final을 사용하면 안 된다.

JPA가 엔티티 객체를 생성할 때 기본 생성자를 사용하므로 이 생성자는 반드시 있어야 하낟. 자바는 생성자가 하나도 없으면 다음과 같은 기본 생성자를 자동으로 만든다.

```java
public Member(){} // 기본 생성자
```

문제는 다음과 같이 생성자를 하나 이상 만들면 자바는 기본 생성자를 자동으로 만들지 않아서 기본 생성자를 직접 만들어야 한다.

```java
public Member() {} // 직접 만든 기본 생성자

//임의의 생성자
public Member(String name){
    this.name = name
}
```


# 4.2 @Table
- @Table 은 엔티티와 매핑할 테이블을 지정한다. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다.

|속성|기능|기본값|
|--|--|--|
|name|매핑할 테이블 이름|엔티티 이름을 사용한다.|
|catalog|catalog 기능이 있는 데이터베이스에서 catalog를 매핑한다.||
|schema|schema 기능이 있는 데이터베이스에서 schema를 매핑한다,|
|uniqueConstraints|DDL 생성 시에 유니크 제약조건을 만든다. 2개 이상의 복합 유니크 제약조건도 만들 수 있다. 참고로 이 기능은 스키마 자동 생성 기능을 사용해서 DDL을 만들 떄만 사용된다.||

### 스키마 자동 생성 기능
스키마 자동 생성 기능을 사용하려면 먼저 peresistence.xml에 다음 속성을 추가해야 한다.
```xml
<property name="hibernate.hbm2ddl.auto" value="create"/>
```
이 속성을 추가하면 애플리케이션 실행 시점에 데이터베이스 테이블을 자동으로 생성한다.
추가로 hibernate.show_sql 속성을 true로 설정하면 콘솔에 실행되는 테이블 생성 DDL(Data Definition Language)을 출력할 수 있다.

 애플리케이션을 실행하면 다음과 같이 콘솔에 DDL이 출력되면서 실제 테이블이 생성된다.

 ```sql
 Hibernate:
    drop table MEMBER if exists
Hibernate:
    create table MEMBER(
        ID varchar(255) not null,
        NAME varchar(255),
        age integer,
        roleType varchar(255),
        createdDate timestamp,
        lastModifiedDate timestamp,
        description clob,
        primary key (ID)
    )
```
- 자동 생성되는 DDL은 지정한 데이터베이스 방언에 따라 달라진다.

- 객체와 테이블을 매핑하는 데 아직 익숙하지 않다면 `데이터베이스 스키마 자동 생성`을 적극 활용하자. 이 기능을 사용해서 생성된 DDL을 보면 엔티티와 테이블이 어덯게 매핑되는 지 알 수 있다.

hinernate.hbm2ddl.auto 속성
|옵션|설명|
|--|--|
|create|기존 테이블을 삭제하고 새로 생성한다. DROP + CREATE|
|create-drop| create 속성에 추가로 애플리케이션을 종료할 때 생성한 DDL을 제거한다. DROP + CREATE + DROP
|update|데이터베이스 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정한다.|
|validate|데이터베이스 테이블과 엔티티 매핑정보를 비교해서 차이가 있으면 경고를 남기고 애플리케이션을 실행하지 않는다. 이 설정은 DDL을 수정하지 않는다.|
|validate| 데이터베이스 테이블과 엔티티 매핑정보를 비교해서 차이가 있으면 경고를 남기고 애플리케이션을 실행하지 않는다. 이 설정은 DDL을 수정하지 않는다.
|none|자동 생성 기능을 사용하지 않으려면 hibernate.hbm2ddl.auto 속성 자체를 삭제하거나 유효하지 않은 옵션 값을 주면 된다(참고로 none은 유효하지 않은 옵션 값이다).|
```
- 참고로 DLL을 수정하는 옵션은 오직 개발 서버에서만 사용해야 한다.
개발 환경에 따른 추천 전략:
- 개발 초기 단계는 create 또는 update
- 초기화 상태로 자동화된 테스트를 진행하는 개발자 환경과 CI 서버는 create 또는 create-drop
- 테스트 서버는 update 또는 validate
- 스테이징과 운영 서버는 validate 또는 none
```

이름 매핑 전략 바꾸기
단어와 단어를 구분할 때 자바 언어는 camel case, 데이터베이스는 snake case를 사용한다.
```java
@Column(name="roly_type")
String roleType
```

이를 hibernate.ejb.naming_strategy 속성을 사용하면 이름 매핑 전략을 변경할 수 있다. 직접 이름 매핑 전략을 구현해서 변경해도 되지만, 하이버네이트는 org.hibernate.cfg.ImprovedNamingStrategy 클래스를 제공한다. 이 클래스는 테이블 명이나 컬럼 명이 생략되면 자바의 카멜 표기법을 테이블의 언더스코어 표기법으로 매핑한다
```xml
<property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy"/>
```
이 속성을 사용해서 만든 테이블은 다음과 같다.

```sql
create table member{
    id varchar(255 char) not null,
    name varchar(255 char),
    age integer,
    role_type varchar(255 char),
    created_date timestamp,
    last_modified_date timestamp,
    description clob,
    primary key (id)
}
```

# 4.5 DDL 생성 기능
- 아래는 회원 이름은 필수로 입력되어야 하고, 10자 를 초과하면 안된다는 제약 조건이 추가되었다
```java
@Entity
@Table(name="MEMBER")
public class Member{

    @Id
    @Column(name="ID")
    private String id;

    @Column(name="NAME", NULLABLE = false, length= 10) //추가
    private String username;
}
```

### 유니크 제약조건
```java
@Entity(name="Member")
@Table(name="MEMBER",uniqueconstraints = {@UniqueConstraint(name = "NAME_AGE_UNIQUE", columnNames = {"NAME","AGE"})})
public class Member{
    
    @Id
    @Column(name = "ID")
    private String id;

    @Column(name = "name")
    private String username;
    ...
}
```

# 4.6 기본 키 매핑
- 이 절에서는 기본 키(Primary Key) 매핑을 사렾본다.

```java
@Entity
public class Member{
    @Id
    @Column(name="ID")
    private String id;
}
```

- 지금 까지 예제 위처럼 @Id 어노테이션만 사용해서 회원의 기본 키를 애플리케이션에 직접 할당했다. 기본 키를 애플리케이션에서 직접 할당하는 대신에 데이터베이스가 생성해주는 값을 사용하려면 어떻게 매핑해야 할까?
- JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다.

- 직접 할당: 기본 키를 애플리케이션에서 직접 할당한다.
- 자동 생성: 대리 키 사용 방식
    - IDENTITY: 기본 키 생성을 데이터베이스에 위임한다.
    - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
    - TABLE: 키 생성 테이블을 사용한다.

 자동 생성 전략이 이렇게 다양한 이유는 데이터베이스 밴더마다 지원하는 방식이 다르기 때문이다. 예를 들어 오라클 데이터베이스는 시퀀스를 제공하지만 MySQL 은 시퀀스를 제공하지 않는다. 대신에 MySQL은 기본 키 값을 자동을 채워주는 AUTO_INCREMENT 기능을 제공한다. TABLE 전략은 키 생성용 테이블을 하나 만들고 마치 시퀀스 처럼 사용하는 방법이다. 이 전략은 테이블을 활용하므로 모든 데이터베이스에 사용할 수 있다.

 기본 키를 직접 할당하려면 @Id만 사용하면 되고, 자동 생성 전략을 사용하려면 @Id 에 @GeneratedValue를 추가하고 원하는 키 생성 전략을 선택하면 된다. 먼저 각각의 전략을 어떻게 사용하는 지 알아보고 @GeneratedValue 어노테이션도 살펴보자.

## 주의사항
```
- 키 생성 전략을 사용하려면 persistence.xml에 hibernate.id.new_generator_mappings=true 속성을 반드시 추가해야 한다. 하이버네이트는 더 효과적이고 JPA 규격에 맞는 새로운 키 생성 전략을 개발했는데 과거 버전과의 호환성을 유지하려고 기본 값을 false로 두었다. 기존 하이버네이트 시스템을 유지보수하는 것이 아니라면 반드시 true로 설정하자. 지금부터 설명하는 내용도 이 옵션을 true로 설정했다고 가정한다.

참고로 이 옵션을 true로 설정하면 키 생성 성능을 최적화하는 allocationSize 속성을 사용하는 방식이 달라진다. allocationSize 속성은 뒤에서 설명한다.
<property name="hibernate.id.new_generator_mappings" value="true"/>
```

## 4.6.1 기본 키 직접 할당 전략
- 기본 키를 직접 할당하려면 다음 코드와 같이 @Id로 매핑하면 된다.
```java

@Id
@Column(name="id")
private String id;
```
@Id 적용 가능 자바 타입은 다음과 같다.
```
- 자바 기본형
- 자바 래퍼(Wrapper)형
- String
- java.util.Date
- java.sql.Date
- Java.math.BigDecimal
- java.math.BigInteger
```
- 기본 키 직접 할당 전략은 em.persist()로 엔티티를 저장하기 전에 애플리케이션에서 기본 키를 직접 할당하는 방법이다.
```java
Board board = new Board();
board.setId("id1") // 기본 키 직접 할당
em.persist(board);
```

기본 키 직접 할당 전략은 em.persist()로 엔티티를 저장하기 전에 애플리케이션에서 기본 키를 직접 할당하는 방법이다.
```java
Board board = new Board();
board.setId("id1") // 기본 키 직접 할당
em.persist(board);
```

## 참고
```
기본 키 직접 할당 전략에서 식별자 값 없이 저장하면 예외가 발생하는데, 어떤 예외가 발생하는지 JPA 표준에는 정의되어 있지 않다. 하이버네이트를 구현체로 사용하면 JPA 최상위 예외인 javax.persistence.PersistenceException 예외가 발생하는데, 내부에 하이버네이트 예외인 org.hibernate.id.identifierGenerationException 예외를 포함하고 있다.
```

## 4.6.2 IDENTITY 전략
- IDENTITY 는 기본 키 생성을 위임하는 전략이다. 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용한다. 예를 들어 MySQL의 AUTO_INCREMENT 기능은 데이터베이스가 기본 키를 자동으로 생성해준다. MySQL의 AUTO_INCREMENT 기능을 수행하는 다음 예제를 보자.
```SQL
CREATE TABLE BOARD(
    ID NOT NULL AUTO_INCREMENT PRIMARY KEY,
    DATA VARCHAR(255)
);

INSERT INTO BOARD(DATA) VALUES('A');
INSERT INTO BOARD(DATA) VALUES('B');
```

테이블을 생성할 때 기본 키 컬럼인 ID에 AUTO_INCREMENT를 추가했다. 이제 데이터베이스에 값을 저장할 때 ID 컬럼을 비워두면 데이터베이스가 순서대로 값을 채워준다.

위 SQL 결과

|ID|DATA|
|--|--|
|1|A|
|2|B|

IDENTITY 전략은 지금 설명한 AUTO_INCREMENT를 사용한 예제처럼 데이터베이스에 값을 저장하고 나서야 기본 키 값을 구할 수 있을 때 사용한다.
 개발자가 엔티티에 직접 식별자를 할당하면 @Id 어노테이션만 있으면 되지만 지금처럼 식별자가 생ㅅ어되는 경우에는 @GeneratedValue 어노테이션을 사용하고 식별자 생성 전략을 선택해야 한다. IDENTITY 전략을 사용하려면 @GeneratedValue의 strategy 속성 값을 GenerationType.IDENTITY로 지정하면 된다. 이 전략을 사용하면 JPA는 기본 키 값을 얻어오기 위해 데이터베이스를 추가로 조회한다.

### IDENTITY 매핑 코드
 ```java
 @Entity
 public class Board{

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    ...
 } 
 ```

### IDENTITY 사용 코드(예제 4.10)
```java
private static void logic(EntityManager em){
    Board board = new Board();
    em.persist(board);
    System.out.println("board.id = " + board.getId());
}
//출력 : board.id=1
```
예제 4.10 코드를 보면 em.persist()를 호출해서 엔티티를 저장한 직후에 할당된 식별자 값을 출력했다. 출력된 값 1은 저장 시점에 데이터베이스가 생성한 값을 JPA가 조회한 것이다.

### 참고
```
IDENTITY 전략과 최적화
IDENTITY 전략은 데이터를 데이터베이스에 INSERT한 후에 기본 키 값을 조회할 수 있다. 따라서 엔티티에 식별자 값을 할당하려면 JPA는 추가로 데이터베이스를 조회해야 한다. JDBC3에 추가된 Statement.getGeneratedKeys()를 사용하면 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어올 수 있다. 하이버네이터는 이 메소드를 사용해서 데이터베이스와 한 번만 통신한다.
```

### 주의
```
엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 그런데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.
```

아래 다양한 전략들이 있다. 이는 시간이 있을 시에 정리할 예정 
## 4.6.3 SEQUENCE 전략
## 4.6.4 TABLE 전략
## 4.6.5 AUTO 전략
## 4.6.4 TABLE 전략

## 4.6.6 기본 키 매핑 정리
- 영속성 컨택스트는 엔티티를 식별자 값을 구분하므로 엔티티를 영속 상태로 만들려면 식별자 값이 반드시 있어야 한다. em.persist()를 호출한 직후에 발생하는 일을 식별자 할당 전략별로 정리하면 다음과 같다.
- 직접 할당: em.persist()를 호출하기 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다. 만약 식별자 값이 없으면 예외가 발생한다.
- SEQUENCE:데이터베이스 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- TABLE: 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- IDENTITY: 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다(IDENTITY 전략은 테이블에 데이터를 저장해야 식별자 값을 획득할 수 있다.)

### 참고
- 권장하는 식별자 선택 전략

권장하는 식별자선택 전략
데이터베이스 기본 키는 다음 3가지 조건을 모두 만족해야 한다.
1. NULL 값은 허용되지 않는다.
2. 유일해야 한다.
3. 변해선 안된다.
테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다.
- 자연 키(natural key)
    - 비즈니스에 의미가 있는 키
    - 예: 주민등록번호, 이메일, 전화번호
- 대리 키(surrogate key)
    - 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로도 불린다.
    - 예: 오라클 시퀀스, auto_increment, 키생성 테이블 사용

<span style="color:yellow; font-size:18px">자연 키보다는 대리 키를 권장한다. </span>

자연 키와 대리 키는 일장 일단이 있지만 될 수 있으면 대리 키의 사용을 권장한다. 예를 들어 자연 키인 전화번호를 기본 키로 선택한다면 그 번호가 유일할 수는 있지만, 전화번호가 없을수도 있고 전화번호가 변경될 수도 있다. 따라서 기본 키로 적당하지 않다. 문제는 주민등록번호처럼 그럴듯하게 보이는 값이다. 이 값은 null 이 아니고 유일하며 변하지 않는다. 3가지 조건을 모두 만족하는 것 같다. 하지만 현실과 비즈니스 규칙은 생각보다 쉽게 변한다. 주민등록 번호조차도 여러 가지 이유로 변경될 수 있다.

<span style="font-size:18px">비즈니스 환경은 언젠가 변한다. </span>

경험담 예시.. 
레거시 시스템을 유지보수할 일이 있었는데, 분석해보니 회원테이블에 주민등록번호가 기본 키로 잡혀 있었다. 회원과 관련된 수많은 테이블에서 조인을 위해 주민등록번호를 외래 키로 가지고 있었고 심지어 자식 테이블의 자식 테이블까지 주민등록 번호가 내려가 있었다. 문제는 정부 정책이 변경되면서 법적으로 주민등록번호를 저장할 수 없게 되면서 발생했다. 결국 데이터베이스 테이블은 물론이고 수많은 애플리케이션 로직을 수정했다. 만약 데이터베이스를 처음 설계할 때부터 자연 키인 주민등록번호 대신에 비즈니스와 관련 없는 대리 키를 사용했다면 수정할 부분이 많지는 않았을 것이다.

기본 키의 조건을 현재는 물론이고 미래까지 충족하는 자연 키를 찾기는 쉽지 않다. 대리 키는 비즈니스와 무관한 임의의 값이므로 요구사항이 변경되어도 기본 키가 변경되는 일은 드물다. 대리 키를 기본 키로 사용하되 주민등록번호나 이메일처럼 자연 키의 후보가 되는 컬럼들은 필요에 따라 유니크 인덱스를 설정해서 사용하는 것을 권장한다.

<span style="color:yellow; font-size:18px"> JPA는 모든 엔티티에 일관된 방식으로 대리 키 사용을 권장한다.</span>

비즈니스 요구사항은 계속해서 변하는데 테이블은 한번 정의하면 병경하기 어렵다. 그런 면에서 외부 풍파에 쉽게 흔들리지 않는 대리 키가 일반적으로 좋은 선택이라 생각한다.


### 주의

기본 키는 변하면 안 된다는 기본 원칙으로 인해, <span style="color:yellow">저장된 엔티티의 기본 키 값은 절대 변경하면 안 된다.</span> 이 경우 JPA는 예외를 발생시키거나 정상 동작하지 않는다. setId() 같이 식별자를 수정하는 메소드를 외부에 공개하지 않는 것도 문제를 예방하는 하나의 방법이 될 수 있다.


# 4.7 필드와 컬럼 매핑: 레퍼런스

- JPA가 제공하는 필드와 컬럼 매핑용 어노테이션들을 레퍼런스 형식으로 정리해보았다.

|분류|매핑 어노테이션|설명|
|--|--|--|
|필드와 컬럼 매핑|@Column|컬럼을 매핑한다.|
||@Enumerated|자바의 enum 타입을 매핑한다.|
||@Temporal|날짜 타입을 매핑한다.|
||@Lob|BLOB, CLOB 타입을 매핑한다.|
||@Transient|특정 필드를 데이터베이스에 매핑하지 않는다.|
|기타|@Access|JPA가 엔티티에 접근하는 방식을 지정한다.|


## 4.7.1 @Column
@Column은 객체 필드를 테이블 컬럼에 매핑한다. 가장 많이 사용되고 기능도 많다.
속성 중에 name, nullable이 주로 사용되고 나머지는 잘 사용되지 않는 편이다.
insertable, updatable 속성은 데이터베이스에 저장되어 있는 정보를 읽기만 하고 실수로 변경하는 것을 방지하고 싶을 때 사용한다.
|속성|기능|기본 값|
|--|--|--|
|name|필드와 매핑할 테이블의 컬럼 이름|객체의 필드 이름|
|nullable(DDL)|null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다.|true|
|unique(DDL)|@Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다. 만약 두 컬럼 이상을 사용해서 유니크 제약조건ㅇ르 사용하려면 클래스 래벨에서 @Table.uniqueConstraints를 사용해야 한다.|
|columnDefinitino(DDL)|데이터베이스 컬럼 정보를 직접 줄 수 있다.|필드와 자바 타입과 방언 정보를 사용해서 적절한 컬럼 타입을 생성한다.|
|length(DDL)|문자 길이 제약조건, String 타입에만 사용한다.|255|
|precision, scale(DDL)|BigDecimal 타입에서 사용한다(Biginteger도 사용할 수 있다). precision은 소수점을 포함한 전체 자릿수를, scale은 소수의 자릿수다. 참고로 double, float 타입에는 적용되지 않는다. 아주 큰 숫자나 정밀한 소수를 다루어야 할 때만 사용한다.|precision=19, scale=2|
|insertable(거의 사용되지 않음)|엔티티 저장 시 이 필드도 같이 저장한다. false로 설정하면 이 필드는 데이터베이스에 저장하지 않는다. false 옵션은 읽기 전용일 때 사용한다.|true|
|updatable(거의 사용되지 않음)|엔티티 수정 시 이 필드도 같이 수정한다. false로 설정하면 데이터베이스에 수정하지 않는다. false 옵션은 읽기 전용일 때 사용한다.|true|
|table(거의 사용되지 않음|하나의 엔티티를 두 개 이상의 테이블에 매핑할 때 사용하낟. 지정한 필드를 다른 테이블에 매핑할 수 있다.|현재 클래스가 매핑 된 테이블|

DDL 생성 속성에 따라 어떤 DDL이 생성되는 지 보자.
### nullable(DDL 생성 기능)
```sql
@Column(nullable = false)
private String data;

// 생성된 DDL
data varchar(255) not null
```

### unique(DDL생성 기능)
```sql
@Column(unique=true)
private String username;

// 생성된 DDL
alter table Tablename add constraint UK_Xxx unique (username)
```

### columnDefinition(DDL생성 기능)
```sql
@Column(columnDefinition = "varchar(100) default 'EMPTY'")
private String data;

// 생성된 DDL
data varchar(100) default 'EMPTY'
```

### legth(DDL생성 기능)
```sql
@Column(length = 400)
private String data;

// 생성된 DDL
data varchar(400)
```

### precision, scale(DDL 생성 기능)
```sql
@Column(precision = 10, scale =2)
private BigDecimal cal;

// 생성된 DDL
cal numeric(10,2) //H2, PostgreSQL
cal number(10,2) // 오라클
cal decimal(10,2) // MySQL
```

### 참고 @Column 생략
@Column을 생략하게 되면 어떻게 될까? -> 대부분 @Column 속성의 기본 값이 적용된다.
자바 기본 타입일 때는 nullable 속성에 예외가 있다. 코드를 보자.
```
int data1; //@Column 생략, 자바 기본 타입
data1 integer not null// 생성된 DDL

Integer data2; //@Column 생략, 객체 타입
data2 integer // 생성된 DDL

@Column
int data3; // @Column 사용, 자바 기본 타입
data3 integer // 생성된 DDL
```
int data1 같은 자바 기본 타입에는 null 값을 입력할 수 없다. Integer data2 처럼 객체 타입일 때만 null 값이 허용된다. 따라서 자바 기본 타입인 int data1을 DDL로 생성할 때는 not null 제약 조건을 추가하는 것이 안전하다.
JPA는 이런 상황을 고려해서 DDL 생성 기능을 사용할 때 int data1 같은 기본 타입에는 not null 제약조건을 추가한다. 반면에 Integer data2처럼 객체 타입이면 null 이 입력될 수 있으므로 not null 제약조건을 설정하지 않는다. 그런데 int data3처럼 @Column을 사용하면 @Column은 nullable=ture가 기본 값이므로 not null 제약조건을 설정하지 않는다. 따라서 <span style="color:yellow">자바 기본 타입에 @Column을 사용하면 nullable = false로 지정하는 것이 안전하다.</span>

## 4.7.2 @Enumerated
- 자바의 enum 타입을 매핑할 때 사용한다.

|속성|기능|기본값|
|--|--|--|
|value| EnumType.ORDINAL: enum 순서를 데이터베이스에 저장<br>EnumType.Sring: enum 이름을 데이터베이스에 저장| EnumType.ORDINAL|

### @Enumerated 사용 예

```java
enum RoleType{
    ADMIN, USER
}
```
다음은 enum 이름으로 매핑한다.
```
@Enumerated(EnumType.STRING)
private RoleType roleType;
```
enum은 다음처럼 사용한다
```
member.setRoleType(RoleType.ADMIN); // -> DB에 문자 ADMIN으로 저장됨
```
@Enumerated 를 사용하면 편리하게 enum 타입을 데이터베이스에 저장할 수 있다.
- EnumType.ORDINAL은 enum에 정의된 순서대로 ADMIN은 0, USER는 1 값이 데이터베이스에 저장된다.
    - 장점: 데이터베이스에 저장되는 데이터 크기가 작다.
    - 단점: 이미 저장된 enum의 순서를 변경할 수 없다.
- EnumType.String은 enum 이름 그대로 ADMIN은 `ADMIN`, USER는 `USER` 라는 문자로 데이터베이스에 저장된다.
    - 장점: 저장된 enum의 순서가 바뀌거나 enum이 추가되어도 안전하다.
    - 단점: 데이터베이스에 저장되는 데이터 크기가 ORDINAL에 비해서 크다.

### 주의
기본 값이 ORDINAL은 주의해서 사용해야 한다.

ADMIN(0번), USER(1번), 사이에 enum이 하나 추가되서 ADMIN(0번) , NEW(1번), USER(2번)로 설정되면 이제부터 USER는 2로 저장되지만 기존에 데이터베이스에 저장된 값은 여전히 1로 남아 있다. <span style="color:yellow">따라서 이런 문제가 발생하지 않는 EnumType.STRING을 권장한다.</span>

## 4.7.3 @Temporal
- 날짜 타입을 매핑할 때 사용한다.
## 4.7.4 @Lob
- 데이터베이스 BLOB, CLOB 타입과 매핑한다.
## 4.7.5 @Transient
- 이 필드는 매핑하지 않는다. 따라서 데이터베이스에 저장하지 않고 조회하지도 않는다. 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.
## 4.7.6 @Access
- JPA가 엔티티 데이터에 접근하는 방식을 지정한다.

# 4.8 정리
- 여기에서는 객체와 테이블 매핑, 기본 키 매핑, 필드와 컬럼 매핑에 대해 알아보았다. 그리고 데이터베이스 스키마 자동 생성하기 기능도 알아보았는데, 이 기능을 사용하면 엔티티 객체를 먼저 만들고 테이블은 자동으로 생성할 수 있다.

- JPA는 다양한 기본 키 매핑 전략을 지원하낟. 기본 키를 애플리케이션에서 직접 할당하는 방법부터 데이터베이스가 제공하는 기본 키를 사용하는 SEQUENCE, IDENTITY, TABLE 전략도 알아 보았다.
 
</details>

<details>

# 10.0 개요


<summary span style="font-size:20px">10. 객체지향 쿼리</summary>


목차
- 객체지향 쿼리 소개
- JPQL
- Criteria
- QueryDSL(가장 선호되는 방법)
- 네이티브 SQL
- 객체지향 쿼리 심화

JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다. 여기에서는 JPQL, Criteria, QueryDSL과 같은 다양한 쿼리 기술을 다룬다. 

JPQL은 가장 중요한 객체지향 쿼리 언어다. 이 장에서 다루는 Criteria나 QueryDSL은 결국 JPQL을 편리하게 사용하도록 도와주는 기술이므로 JPA를 다루는 개발자라면 JPQL을 필수로 학습해야 한다. 
# 10.1 객체지향 쿼리 소개
EntityManager.find() 메소드를 사용하면 식별자로 엔티티 하나를 조회할 수 있다. 이렇게 조회한 엔티티에 객체 그래프 탐색을 사용하면 연관된 엔티티들을 찾을 수 있다. 이 둘은 가장 단순한 검색 방법이다.
<details>
<summary span style="font-size:20px">10.1.1 ~ 10.1.2 객체 지향 쿼리 소개 ~ Criteria 소개</summary>

- 식별자로 조회 EntityManager.find()
- 객체 그래프 탐색 (예, a.getB().getC())

이 기능만으로 애플리케이션을 개발하기는 어럅다. 예를 들어 나이가 30살 이상인 회원을 모두 검색하고 싶다면 좀 더 현실적이고 복잡한 검색 방법이 필요하다. 그렇다고 모든 회원 엔티티를 메모리에 올려두고 애플리케이션에서 30살 이상인 회원을 검색하는 것은 현실성이 없다.<span style="color:yellow"> 결국 데이터는 데이터베이스에 있으므로 SQL로 필요한 내용을 최대한 걸러서 조회해야 한다.</span> 하지만 ORM을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요하다.

<span style="color:yellow">JPA는 이러한 문제들을 해결하기 위해 만들어 졌다.</span>

<span style="color:yellow; font-size:20px">JPA 특징
- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.
- SQL을 추상화해서 특정 데이터베이스에 SQL에 의존하지 않는다.

SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리라면 <span style="color:yellow">JPQL은 엔티티 객체를 대상으로 하는 객체지향 쿼리다.</span>
JPQL을 사용하면 JPQ는 이 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스르 조회한다. 그리고 조회한 결과로 엔티티 객체를 생성해서 반환한다.

JPQL을 한마디로 정의하면 객체지향 SQL이다. 처음 보면 SQL로 오해할 정도로 문법이 비슷하다. 따라서 SQL에 익숙한 개발자는 몇 가지 차이점만 이해하면 쉽게 적응할 수 있다.

JPA는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다. 다음은 JPQ가 공식 지원하는 기능이다.
- <span style="color:yellow; font-size:18px">JPQL(Java Query Language) </span>
- Criteria 쿼리(Criteria Query): JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.
다음은 JPA가 공식 지원하는 기능은 아니지만 알아두면 좋다.
- QueryDSL: Criteria 쿼리처럼 JPQL을 편하게 작성하도로 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크다.
- <span style="color:yellow">JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용: 필요하면 JDBC를 직접 사용할 수 있다</span>

가장 중요한 것은 JPQL이다.

## 10.1.1 JPQL 소개
JPQL(Java Persistence Query Language)은 객체를 조회하는 객체지향 쿼리다. 문법은 SQL과 비슷하고 ANSI 표준 SQL이 제공하는 기능을 유사하게 지원한다.

<span style="color:yellow">JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않고, 간결하다.</span>

### 예제 10.1 회원 엔티티
```java
@Entity(name="Member")
public class Member{
    @Column(name="name")
    private String username;
    //...
}
```
### 예제 10.2 JPQL 사용
```java
// 쿼리 생성
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```
예제 10.2는 회원이름이 kim인 엔티티를 조회한다. JPQL에서 member는 엔티티 이름이다. 그리고 m.username은 테이블 컬럼명이 아니라 엔티티 객체의 필드명이다.

 em.createQuery() 메소드에 실행할 JPQL과 반환할 엔티티의 클래스 타입인 Member.class 를 넘겨주고 getResultList() 메소드를 실행하면 JPA는 JPQL을 SQL로 변환해서 데이터베이스를 조회한다. 그리고 조회한 결과로 Member 엔티티를 생성해서 반환한다.

이때 실행한 JPQL은 다음과 같다
```sql
select m
from Member as m
where m.username = 'kim'
```
실제 실행된 SQL은 다음과 같다.
```sql
select
    member.id as id,
    member.age as age,
    member.team_id as team,
    member.name as name
from
    Member member
where
    member.name='kim'
```
참고로 하이버네이트 구현체가 생성한 SQL은 별칭이 너무 복잡해서 알아보기 쉽게 수정했다.

## 10.1.2 Criteria 쿼리 소개 (복잡하고 장황함)
- Criteria는 JPQL을 생성하는 빌더 클래스다. Criteria의 장점은 문자가 아닌<span style="color:yellow;font-size:17px"> query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있다</span>는 점이다.


문자로 작성한 JPQL보다 코드로 작성한 Criteria의 장점은 다음과 같다.
- 컴파일 시점에 오류를 발견할 수 있다.
- IDE를 사용하면 쿼리 자동완성을 지원한다.
- 동적 쿼리를 작성하기 편하다.

하이버네이트를 포함한 몇몇 ORM 프레임워크들은 이미 오래 전부터 자신만의 Criteria를 지원했다. JPA는 2.0부터 지원한다.

### 예제 10.3 Criteria 쿼리
```java
// Criteria 사용 준비
CreteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```

예제 10.3을 보면 쿼리를 문자가 아닌 코드로 작성한 것을 확인할 수 있다. 아쉬운 점은 m.get("username")을 보면 필드 명을 문자로 작성했다. 만약 이 부분도 문자가 아닌 코드로 작성하고 싶으면 메타 모델(MetaModel)을 사용하면 된다.

### 예시
```java
//메타 모델 사용 전 -> 사용 후
```m.get("username") -> m.get(Member_.username)
```
이 코드를 보면"username"이라는 문자에서 Member_.username이라는 코드로 변경된 것을 확인할 수 있다. 참고로 Criteria는 코드로 쿼리를 작성할 수 있어서 동적 쿼리를 작성할 때 유용하다.

Criteria가 가진 장점이 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다.
</details>


## <span style="color:yellow">10.1.3 QueryDSL 소개 (중요, 가장 선호하는 방법)</span>
QueryDSL도 Criteria 처럼 JPQL 빌더 역할을 한다. QueryDSL의 장점은 코드 기반이면서 단순하고 사용하기 쉽다. 그리고 작성한 코드도 JPQL과 비슷해서 한눈에 들어온다. QUeryDSL과 Criteria를 비교하면 Criteria는 너무 복잡하다.

### 참고
QueryDSL은 JPA 표준은 아니고 오픈소스 프로젝트다. 이것은 JPA뿐만 아니라 JDO, MongoDB, Java Collection, Lucene, Hibernate Search도 거의 같은 문법으로 지원한다. 현재 스프링 데이터 프로젝트가 지원할 정도로 많이 기대되는 프로젝트다.

### 예제 10.4 QueryDSL 코드
```java
// 준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

//쿼리, 결과조회
List<Member> members =
    query.from(member)
    .where(member.username.eq("kim"))
    .list(member);
```
QueryDSL을 사용하는 예제 10.4는 코드 만으로 이해가 가능할 것이다.

## 10.1.4 네이티브 SQL 소개
- JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는 데, 이것을 네이티브 SQL이라고 한다.
단점은 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는 것이다. 따라서 데이터베이스를 변경하면 네이티브 SQL도 수정해야 한다.
### 예제 10.5 네이티브 SQL
```java
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = `kim`";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```
예제 10.5를 보면 네이티브 SQL은 em.createNativeQuery()를 사용하면 된다. 나머지 API는 JPQL과 같다. 실행하면 직접 작성한 SQL을 데이터베이스에 전달한다.

## 10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임 워크
(일단 패스)


# 10.2 JPQL
(정리 필수, QueryDSL 정리부터 먼저하기)
# 10.3 Criteria
- JPA Criteria는 문자가 아닌 코드로 JPQL을 작성하므로 문법 오류를 컴파일 단계에서 잡을 수 있고 IDE 자동완성 기능의 도움을 받을 수 있는 등 여러 가지 장점이 있다. 하지만 Criteria의 가장 큰 단점은 너무 복잡하고 어렵다.

# 10.4 QueryDSL
- QueryDSL은 오픈소스 프로젝트다. 이는 이름 그대로 데이터를 조회하는 데 기능이 특화되어 있다.
## 참고
QueryDSL은 최범균(javacon.tistory.com)님이 번역한 공식 한국어 문서를 제공한다.

[QueryDSL 공식 문서 한국어 링크](www.querydsl.com/static/querydsl/3.6.3/reference/ko-KR/html_single/)

-> Spring Data JPA 부터 보기
</details>

<details>


<summary span style="font-size:20px">12. Spring Data JPA</summary>

# 12. Spring Data JPA

여기에서 일단 볼 것은 query 짜는 부분인 12.3과 12.4장 이다.

![image](https://user-images.githubusercontent.com/51036842/181485902-761e1f3e-5c80-4816-94e7-b31700361ba0.png)

출처: https://www.inflearn.com/course/스프링-데이터-jpa

- Spring Data JPA는 Spring Data 프로젝트의 하위 프로젝트 중 하나이다.


- 대부분의 데이터 접근 계층(Data Access Layer)은 일명 CRUD로 부르는 코드를 반복해야 한다.

### 예제 12.1 JPA의 반복적인 CRUD
```java
public class MemberRepository{

    @PersistenceContext
    EntityManager em;

    public void save(Member member){...}
    public Member findOne(Long id){...}
    public List<Member> findAll(){...}

    public Member findByUsername(String username){...}
}

public class ItemRepository{
    
    @PersistenceContext
    EntityManager em;

    public void save(Item item){...}
    public Member findOne(Long id){...}
    public List<Member> findAll(){...}
}
```
예제 12.1 을 보면 회원 리포지토리(MemberRepository)와 상품 리포지토리(ItemRepository)가 하는 일이 비슷하다. 이런 문제를 해결하려면 제네릭 상속을 적절히 사용해서 공통 부분을 처리하는 부모 클래스를 만들면 된다. 이것을 보통 GenericDAO라 한다. 하지만 이 방법은 공통 기능을 구현한 부모 클래스에 너무 종속되고 구현 클래스 상속이 가지는 단점에 노출된다.

# 12.1 스프링 데이터 JPA 소개
스프링 데이터 JPA는 앞의 반복되는 CRUD 문제를 해결한다.

<span style="color:yellow">스프링 데이터 JPA는 데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수 있다.</span>

CRUD를 처리하기 위한 공통 메소드는 스프링 데이터 JPA가 제공하는 org.springframework.data.jpa.repository.JpaRepository 인터페이스에 있다. 그리고 회원과 상품 리포지토리 인터페이스의 구현체는 애플리케이션 실행 시점에 스프링 데이터 JPA가 생성해서 주입해준다. 따라서 개발자가 직접 구현체를 개발하지 않아도 된다.

### 예제 12.2 스프링 데이터 JPA 적용
```java
public interface MemberRepository extends JpaRepository<Member,Long>{
    Member findByUsername(String username);
}

public interface ItemRepository extends JpaRepository<Item,Long>{}
```
클래스 다이아그램은 그림 12.1과 같다.
### 그림 12.1
![KakaoTalk_20220728_191802488](https://user-images.githubusercontent.com/51036842/181482373-f3e9dcc8-5c50-4cd3-a3ed-417c61d26c9a.jpg)

일반적인 CRUD 메소드는 JpaRepository 인터페이스가 공통으로 제공하므로 문제가 없다. 그런데 MemberRepository.findByUsername(...)처럼 직접 작성한 공통으로 처리할 수 없는 메소드는 어떻게 해야 할까? 놀랍게도 <span style="color:yellow">스프링 데이터 JPA는 메소드 이름을 분석해서 다음 JPQL을 실행한다.</span>

# 12.2 스프링 데이터 JPA 설정
- 스프링 데이터 JAP를 사용하기 위한 라이브러리와 환경설정 방법을 알아보자.

## 필요 라이브러리
- 스프링 데이터 JPA는 예제 12.3과 같이 spring-data-jpa 라이브러리가 필요하다. 예제에서는 1.8.0.RELEASE 버전을 사용한다.

### 예제 12.3 스프링 데이터 jpa Maven 라이브러리 설정
```XML
<!-- 스프링 데이터 JPA -->
<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-jpa</artifactId>
    <version>1.8.0.RELEASE</version>
</dependency>
```
### 참고
spring-data-jpa는 spring-data-common에 의존하므로 두 라이브러리를 함께 받는다.

## 환경설정
예제 12.4와 같이 스프링 설정에 XML을 사용하면 <jpa:repositories>를 사용하고 리포지토리를 검색할 base-package를 적는다. 참고로 해당 패키지와 그 하위 패키지를 검색한다.
### 예제12.4 XML 설정 (appConfig.xml)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

	<jpa:repositories base-package="jpabook.jpashop.repository" />
</beans>
```

스프링 설정에 JavaConfig를 사용하면 예제 12.5와 같이 org.springframework.data.jpa.repository.config.EnableJpaRepositories 어노테이션을 추가하고 basePackages에는 리포지토리를 검색할 패키지 위치를 적는다.

```java
@Configuration
@EnableJpaRepositories(basePackages = "jpabook.jpashop.repository")
public class AppConfig()
```
환경 설정은 이것으로 끝이다.

스프링 데이터 JPA는 애플리케이션을 실행할 때 basePackage에 있는 리포지토리 인터페이스들을 찾아서 해당 인터페이스를 구현한 클래스를 동적으로 생성한 다음 스프링 빈으로 등록한다. 따랏서 개발자가 직접 구현 클래스를 만들지 않아도 된다.(그림 12.3)

### 그림 12.3 구현 클래스 생성

![image](https://user-images.githubusercontent.com/51036842/181484418-41f04c8f-3256-4b2b-ac05-912103ba4d56.png)

# 12.3 <span style="color:yellow">공통 인터페이스 기능</span>
스프링 데이터 JPA는 간단한 CRUD 기능을 공통으로 처리하는 예제 12.6의 JpaRepository 인터페이스를 제공한다. 스프링 데이터 JPA를 사용하는 가장 단순한 방법은 예제 12.7과 같이 이 인터페이스를 상속받는 것이다. 그리고 이 제네릭에 엔티티 클래스와 엔티티 클래스가 사용하는 식별자 타입을 지정하면 된다.

### 예제 12.6 JpaRepository 공통 기능 인터페이스
```java
public interface JpaRepository<T, ID extends Serializable> extends PagingAndSortingRepository<T,ID>{
    ...
}
```

### 예제 12.7 JpaRepository를 사용하는 인터페이스
```java
public interface MemberRepository extends JpaRepository<Member,Long>{}
```

예제 12.7의 상속받은 JpaRepository<Member, Long> 부분을 보면 제너릭에 회원 엔티티와 회원 엔티티의 식별자 타입을 지정했다. 

### 그림 12.4 공통 인터페이스 구성
![image](https://user-images.githubusercontent.com/51036842/181485363-09bbfdc8-1730-4b38-8f2a-7995c2690a02.png)

위 그림 12.4를 보면 윗 부분에 스프링 데이터 모듈이 있고 그 안에 Repository, CrudRepository, PagingAndSortingRepository가 있는데 이것은 스프링 데이터 프로젝트가 공통으로 사용하는 인터페이스다. 스프링 데이터 JPA 가 제공하는 JpaRepository 인터페이스는 여기에 추가로 JPA에 특화된 기능을 제공한다. 
 
 <span style="color:yellow">아래는 JpaRepository 인터페이스를 상속받으면 사용할 수 있는 주요 메서드 몇 가지를 간단히 소개한다. 참고로 T는 엔티티, ID는 엔티티의 식별자 타입, S는 엔티티와 그 자식 타입을 뜻한다.</span>
|메소드|설명|
|--|--|
|save(S)|새로운 엔티티는 저장하고 이미 있는 엔티티는 수정한다.|
|delete(T)|엔티티 하나를 삭제한다. 내부에서 EntityManager.remove()를 호출한다.|
|findOne(ID)|엔티티 하나를 조회한다. 내부에서 EntityManager.find()를 호출한다.|
|getOne(ID)|엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference()를 호출한다.|
|findAll(...)|모든 엔티티를 조회한다. 정렬(Sort)이나 페이징(Pageable) 조건을 파라미터로 제공할 수 있다.|

save(S) 메소드는 엔티티에 식별자가 없으면(null) 이면 새로운 엔티티로 판단해서 EntityManager.persist()를 호출하고 필요하다면 스프링 데이터 JPA의 기능을 확장해서 신규 엔티티 판단 전략을 변경할 수 있다.

 JpaRepository 공통 인터페이스를 사용하면 일반적인 CRUD를 해결할 수 있다. 
 
[JPA 공통 interface 사용 예시](https://velog.io/@mmy789/Spring-Data-JPA-%EA%B3%B5%ED%86%B5-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B8%B0%EB%8A%A5)

 # <span style="color:yellow">12.4 쿼리 메소드 기능 <span>

쿼리 메소드 기능은 스프링 데이터 JPA가 제공하는 마법 같은 기능이다. 대표적으로 메소드 이름만으로 쿼리를 생성하는 기능이 있는데 인터페이스에 메소드만 선언하면 해당 메소드의 이름으로 적절한 JPQL 쿼리를 생성해서 실행한다.

 스프링 데이터 JPA가 제공하는 쿼리 메소드 기능은 크게 3가지가 있다.

- 메소드 이름으로 쿼리 생성
- 메소드 이름으로 JPA NamedQuery 호출
- @Query 어노테이션을 사용해서 리포지토리 인터페이스에 쿼리 직접 정의

이 기능들을 활용하면 인터페이스만으로 필요한 대부분의 쿼리 기능을 개발할 수 있다.

## 12.4.1 메소드 이름으로 쿼리 생성
이메일과 이름으로 회원을 조회하려면 다음과 같은 메소드를 정의하면 된다.

```java
public interface MemberRepository extends Repository<Member, Long> {
    List<Member> findByEmailAndName(String email, String name);
}
```

인터페이스에 정의한 findByEmailAndName(...) 메소드를 실행하면 스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성하고 실행한다. 실행된 JPQL은 다음과 같다.

```sql
select m from Member m where m.email = ?1 and m.name = ?2
```

물론 정해진 규칙에 따라서 메소드 이름을 지어야 한다. 다음은 스프링 데이터 JPA 공식 문서가 제공하는 표이다.

 ### 표 12.1 ⭐⭐스프링 데이터 JPA 쿼리 생성 기능(출처: https://docs.spring.io/spring-data/jpa/docs/1.8.0.RELEASE/reference/html) 뒤에 /jpa.repositories.html가 붙는데 들어가면 안나옴..

 |키워드|예|JPQL 예|
 |--|--|--|
 |And|findByLastname<span style="color:yellow">And</span>Firstname| ... where x.lastname = ?1 and x.firstname = ?2|
 |Or|findByLastname<span style="color:yellow">Or</span>Firstname|... where x.lastname = ?1 or x.firstname=?2|
 |Is, Equals|findByFirstname, findByFirstname<span style="color:yellow">Is</span>, findByFirstname<span style="color:yellow">Equals</span>| ... where x.firstname = 1?
 |Between|findByStartDate<span style="color:yellow">Between</span>|... where x.startDate between 1? and ?2|
 |LessThan| findByAge<span style="color:yellow">LessThan</span>|... where x.age < ?1|
 |LessThanEqual<br>GreaterThan|findByAge<span style="color:yellow">LessThanEqual</span><br>findByAge<span style="color:yellow">GreaterThan</span>| ... where x.age <=?1<br> ... where x.age > ?1|
 |GreaterThanEqual|findByAge<span style="color:yellow">GreaterThanEqual</span>| ... where x.age >= ?1|
 |After|findByStartDate<span style="color:yellow">After</span>|... where x.startDate > ?1|
 |Before| findByStartDate<span style="color:yellow">Before</span>| ... where x.startDate < ?1|
 |IsNull| findByAge<span style="color:yellow">IsNull</span>| ... where x.age is null|
 |IsNotNull, NotNull|findByAge<span style="color:yellow">(Is)NotNull</span>| ... where x.age not null|
 |Like| findByFirstname<span style="color:yellow">Like</span>| ... where x.firstname like ?1|
 |NotLike| findByFirstname<span style="color:yellow">NotLike</span>| ... where x.firstname not like ?1|
 |StartingWith|findByFirstname<span style="color:yellow">StartingWith</span>| ... where x.firstname like ?1<br>(parameter bound with appended %)|
 |EndingWith|findByFirstname<span style="color:yellow">EndingWith</span>|... where x.firstname like ?1<br> (parameter bound with prepended %)|
|Containing|findByFirstname<span style="color:yellow">Containing</span>| ... where x.firstname like ?1<br>(parameter bound with wrapped in %)
|OrderBy|findByAge<span style="color:yellow">OrderBy</span>LastnameDesc| ... where x.age = ?1 order by x.lastname desc|
|Not|findByLastname<span style="color:yellow">Not</span>|... where x.lastname <> ?1|
|In|findByAge<span style="color:yellow">In(Collection ages)</span>|... where x.age in ?1|
|NotIn|findByAge<span style="color:yellow">NotIn(Collection age)</span>| ... where x.age not in ?1|
|True| findByActive<span style="color:yellow">True()</span>|... where x.active=true|
|FALSE| findByActive<span style="color:yellow">False()</span>|... where x.active=false|
|IgnoreCase| findByFirstname<span style="color:yellow">IgnoreCase</span>| ... where UPPER(x.firstname) = UPPER(?1)|
표 12.1은 스프링 데이터 JPA 공식 문서가 제공하는 쿼리 생성 기능이다.

참고로 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메소드 이름도 꼭 함게 변경해야 한다. 그렇지 않으면 애플리케이션을 시작하는 시점에 오류가 발생한다.

## 12.4.2 JPA Named Query
<span style="color:yellow">스프링 데이터 JPA는 메소드 이름으로 JPA Named 쿼리를 호출하는 기능을 제공한다.</span>
JPA Named 쿼리는 이름 그대로 쿼리에 이름을 부여해서 사용하는 방법인데, 예제 12.8과 같이 어노테이션이나 예제 12.9와 같이 XML에 쿼리를 정의할 수 있다. 상세한 내용은 10.2.15 참고. 그리고 같은 방법으로 Named 네이티브 쿼리도 지원한다.

### 예제 12.8 @NamedQuery 어노테이션으로 Named 쿼리 정의
 ```java
@NamedQuery(name = "Memer.findByUsername", query ="select m from Member m where m.username = :username")
public class Member{
    ...
}
```

### 예제 12.9 orm.xml의 XML 사용(pass)
### 예제 12.10 JPA를 직접 사용해서 Named 쿼리 호출 사용(pass)

스프링 데이터 JPA를 사용하면 12.11과 같이 메소드 이름만으로 Named 쿼리를 호출할 수 있다.
### 예제 12.11 스프링 데이터 JPA로 Named 쿼리 호출
```java
public interface MemberRepository extends JpaRepository<Member, Long> // 여기 선언한 도메인 클래스

    List<Member> fubdByUsername(@Param("username") String username);
}
```
스프링 데이터 JPA는 선언한 "도메인 클래스 + .(점) + 메소드 이름" 으로 Named 쿼리를 찾아서 실행한다. 따라서 예제는 Member.findByUsername 이라는 Named 쿼리를 실행한다. 만약 실행할 Named 쿼리가 없으면 메소드 이름으로 쿼리 생성 전략을 사용한다(필요하면 전략을 변경할 수 있다).

 예제 12.11에서 findByUsername() 메소드의 파라미터에 @Param을 사용했는데 이것은 이름기반 파라미터를 바인딩 할 떄 사용하는 어노테이션이다. 자세한 내용은 뒤에 파라미터 바인딩에서 나온다.

## 12.4.3 @Query, 리포지토리 메소드에 쿼리 정의
리포지토리 메소드에 직접 쿼리를 정의하려면 예제 12.12와 같이 @org.springframework.data.jpa.repository.Query 어노테이션을 사용한다. 이 방법은 실행할 메소드에 정적 쿼리를 직접 작성하므로 이름 없는 Named 쿼리라 할 수 있다. 또한 JPA Naemd 쿼리처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있는 장점이 있다.

### 예제 12.12 메소드에 JPQL 쿼리 작성
```java
public interface MemberRepository extends JpaRepository<Member,Long>{
    @Query("select m from Member m where m.username = ?1")
    Member findByUsername(String username);
}
```
네이티브 SQL을 사용하려면 예제 12.13와 같이 @Query 어노테이션에 nativeQuery = true를 설정한다. 참고로 스프링 데이터 JPA가 지원하는 파라미터 바인딩을 사용하면 JPQL은 위치 기반 파라미터를 1부터 시작하지만 네이티브 SQLㅇ느 예제 12.13과 같이 0부터 시작한다.
### 예제 12.13 JPA 네이티브 SQL 지원
```java
public interface MemberRepository extends JpaRepository<Member, Long>

## 12.4.4 파라미터 바인딩

- 스프링 데이터 JPA는 위치 기반 파라미터 바인딩과 이름 기반 파라미터 바인딩을 모두 지원한다.
```sql
select m from Member m where m.username = ?1 // 위치 기반
select m from Member m where m.username = :name // 이름 기반
```

기본값은 위치 기반인데 파라미터 순서로 바인딩한다. 이름 기반 파라미터 바인딩을 사용하려면 에제 12.14와 같이 org.springframework.data.repository.query.Param(파라미터 이름) 어노테이션을 사용하면 된다. 코드 코드 가독성과 유지보수를 위해 이름 기반 파라미터 바인딩을 사용하자.

### 예제 12.14 파라미터 바인딩
```java
import org.springframework.data.repository.query.Param

public interface MemberRepository extends JpaRepository<Member, Long>{
    
    @Query("select m from Member m where m.username = :name")
    Member findByUsername(@Param("name") String username);
}
```

## 12.4.5 벌크성 수정 쿼리
## 12.4.6 반환 타입
## 12.4.7 페이징과 정렬
## 12.4.8 힌트
- JPA 쿼리 힌트를 사용하려면 org.springframework.data.jpa.repository.QueryHints 어노테이션을 사용하면 된다. 참고로 이것은 SQL 힌트가 아니라 JPA 구현체에게 제공하는 힌트다.

# 12.5 명세(아직 불필요)

- 명세(Specification)를 이해하기 위한 핵심 단어는 술어(predicate)인데 이것은 단순히 참이나 거짓으로 평가된다. 그리고 이것은 AND, OR 같은 연산자로 조합할 수 있다.

 - 예를 들어 데이터를 검색하기 위한 제약 조건 하나하나를 술어라 할 수 있다. 이 술어를 스프링 데이터 JPA는 org.springframework.data.jpa.domain.Specification 클래스로 정의했다.

- Specification은 컴포지트 패턴(en.wikipedia.org/wiki/Compositie)으로 구성되어 있어서 여러 Specification을 조합할 수 있다. 따라서 다양한 검색조건을 조립해서 새로운 검색조건을 쉽게 만들 수 있다.

명세 기능을 사용하려면 예제 12.21과 같이 리포지토리에서 org.springframework.data.jpa.repository.JpaSpecificationExecutor 인터페이스를 상속받으면 된다.

### 예제 12.21 JpaSpecificationExecutor 상속
```java
public interface OrderRepository extends JpaRepository<Order, Long>,   JpaSpecificationExecutor<Order>{}  
```
### 예제 12.22 JpaSpecificationExcutor 인터페이스
```java
public interface JpaSpecificationExecutor<T>{

    T findOne (Specification<T> spec);
    List<T> findAll(Speicification<T> spec);
    Page<T> findAll(Specification<T> spec, Pageable pageable);
    List<T> findAll(Specification<T> spec, Sort sort);
    long count(Specification<T> spec);
}
``` 

예제 12.22의 JpaSpecifiactionExecutor의 메소드들은 Specification을 파라미터로 받아서 검색 조건을 사용한다.

이제 명세를 사용하는 예제 12.23을 보자. 우선 명세를 사용하는 코드를 보고 나서 명세를 정의하는 코드를 q보자

### 예제 12.23 명세 사용 코드
```java
import static org.springframework.data.jpa.domain.Specifications.*; //where()
import static jpabook.jpashop.domain.spec.OrderSpec.*; // 중요

public List<Order> findOrders(String name){
    List<Order> result = orderRepository.findAll(
        where(memberName(name)).and(isOrderStatus())
    );
    return result;
}
```

Specifications는 명세들을 조립할 수 있도록 도와주는 클래스인데 where(), and(), or(), not() 메소드를 제공한다.

findAll을 보면 회원 이름 명세(membername)와 주문 상태 명세(isOrderStatus)를 and로 조합해서 검색 조건으로 사용한다.

참고로 명세 기능을 사용할 때 예제처럼 자바의 import static를 적용하면 더 읽기 쉬운 코드가 된다.

이제 12.24의 OrderSpec 명세를 정의하는 코드를 보자.
### 예제 12.24 OrderSpec 명세를 정의 코드
```java
package jpabook.jpashop.domain;

import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;
import javax.persistence.criteria.*;

public class OrderSpec{
    public static Specification<Order> memberName(final String memberName){
        return new Specification<Order>(){
            public Predicate toPredicate(Root<Order> root, CriteriaQuery<?> query, CriteriaBuilder builder){
                if (StringUtils.isEmpty(memberName)) return null;

                Join<Order, Member> m = root.join("member", JoinType.INNER); //회원과 조인
                return builder.equal(m.get("name"),memberName);
            }
        };
    }

    public static Specification<Order> isOrderStatus(){
        return new Specification<Order>(){
            public Predicate toPredicate(Root<Order> root, CriteriaQuery<?> query, CriteriaBuilder builder){
                return builder.equal(root.get("status"), OrderStatus.ORDER);
            }
        };
    }
}
```

명세를 정의하려면 Specification 인터페이스르 정의하면 된다. 예제에서는 편의상 내부 무명 클래스를 사용했다. 명세를 정의할 때는 toPredicate(...) 메소드만 구현하면 되는데 JPA Criteria의 Root, CriteriaQuery, CriteriaBuilder 클래스가 모두 파라미터로 주어진다. 이 파라미터들을 활용해서 적절한 검색 조건을 반환하면 된다. JPA Criteria에 대한 이해가 부족하면 10.3절을 참고하자.

# 12.6 사용자 정의 리포지토리 구현(pass)

# 12.7 Web 확장
스프링 데이터 프로젝트는 스프링 MVC에서 사용할 수 있는 편리한 기능을 제공한다. 식별자로 도메인 클래스를 바로 바인딩해주는 도메인 클래스 컨버터 기능과, 페이징과 정렬 기능을 알아보자.

## 12.7.1 설정
스프링 데이터가 제공하는 Web 확장 기능을 활성화하려면 org.springframework.data.web.config.SpringDataWebConfiguration을 스프링 빈으로 등록하면 된다.
```xml
<bean class = "org.springframework.data.web.config.SpringDataWebConfiguration"/>
```
JavaConfig를 사용하면 다음과 같이 org.springframework.data.web.config.EnableSpringDataWebSupport 어노테이션을 사용하면 된다.
```java
@Configuration
@EnableWebMvc
@EnableSpringDataWebSupport
public class WebAppConfig(
    ...
)
```
설정을 완료하면 도메인 클래스 컨버터와 페이징과 정렬을 위한 HandlerMethodArgumentResolver가 스프링 빈으로 등록된다.

등록되는 클래스 컨버터는 다음과 같다.
```xml
org.springframework.data.repository.support.DomainClassConverter
```

## 12.7.2 도메인 클래스 컨버터 기능
</details>
![Untitled (1)](https://user-images.githubusercontent.com/87989933/176587263-40c20c0b-0576-41b5-bda1-ee3e162aa064.png)

# **SOLID - 좋은 객체지향설계의 5가지 원칙**

## SRP 단일책임원칙 (Single responsibility principle)

**하나의 클래스는 하나의 책임만 가져야한다.**

**중요한 기준은 변경이다.** 변경이 있을때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
이를 지키지 않으면, 한 책임의 변경에 의해 **다른 책임과 관련된 코드에 영향을 미칠 수** 있다.
→ 이렇게 되면 **유지보수가 매우 비효율적**이다.

여기서말하는 **책임이란, '기능,역할'로 생각**하면 된다. 만약 **한 클래스가 수행할 수 있는 기능,역할(책임) 이 여러 개라면, 클래스 내부의 함수끼리 강한 결합을 발생할 가능성이 높아진다.**

응집도는 높고 결합도는 낮은 프로그램을 설계하는 것이 비로소 객체지향 설계의 핵심인데, 이것이 위반되는 것이다. 새로운 요구사항이나 프로그램 변경에 의해 클래스 내부의 동작들이 연쇄적으로 변경되어야 할 수도 있다.
이는 **유지보수가 비효율적**이므로, 책임을 잘게 쪼개어 분리시킬 필요가 있다.

단일 책임 원칙을 제대로 지키면 변경이 필요할 때 수정할 대상이 명확해진다.

그리고 이러한 단일 책임 원칙의 장점은 시스템이 커질수록 극대화되는데, 시스템이 커지면서 서로 많은 의존성을 갖게되는 상황에서 변경 요청이 오면 딱 1가지만 수정하면 되기 때문이다.
단일 책임 원칙을 적용하여 적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 추상화함으로써 애플리케이션의 변화에 손쉽게 대응할 수 있다.

## OCP 개방-폐쇄 원칙 (Open-closed principle)

**소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야한다.**

어떤 기능을 수정할때, 그 기능을 사용하는 모듈을 고치지않고, 즉, **기존의 코드를 변경하지 않고** 기능을 **수정하거나 추가**할 수 있도록 설계해야 한다.

DB에서의 개방-폐쇄원칙의 가장 좋은 예 : JDBC

![Untitled (2)](https://user-images.githubusercontent.com/87989933/176587268-f0d8814f-1998-46d9-975f-4b2a89152833.png)

데이터베이스가 MySQL에서 오라클로 바뀌더라도 Connection을 설정하는 부분만 변경해주면 된다.
즉, 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀 있는 것이다. 데이터베이스를 교체한다는 것은 데이터베이스가 자신의 확장에는 열려 있다는 것이다.

**확장에 대해 열려 있다** : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.  
**수정에 대해 닫혀 있다** : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.

다형성을 활용하여 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하게되면,
클라이언트가 구현 클래스를 직접 선택할때, 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.

개방 폐쇄원칙을 무시하고 프로그램을 작성하면, 객체지향 프로그램밍의 가장 큰 장점인 유연성,재사용성, 유지보수성 등을 얻을 수 없다.  
자주 **변화하는 부분을 추상화함**으로써 **기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 함**으로써 유연함을 높이는 것이 핵심이다.

## LSP 리스코프 치환 원칙 (Liskov substitution principle)

**서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.**

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
다형성에서 하위클래스는 인터페이스 규약을 다 지켜야 한다는 것으로, 다형성을 지원하기 위한 원칙이다.

인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다

결국은, **리스코프 치환 원칙을 지키지 않으면 개방 폐쇄 원칙을 위반**하게 되는 것이다.
기능 확장을 위해 기존의 코드를 여러 번 수정해야 할 것이다.
따라서 상속 관계를 잘 정의하여 LSP 원칙이 위배되지 않도록 설계해야 한다.

## ISP 인터페이스 분리 원칙 (Interface segregation principle)

클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.

특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.  
따라서, **인터페이스 분리 원칙은 각 역할에 맞게 인터페이스로 분리하는 것이다.**

ex) 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리  
사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리

인터페이스가 명확해지고, 대체 가능성이 높아진다.

각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 하는 것이 핵심이다.

## DIP 의존관계 역전 원칙 (Dependency inversion principle)

프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”

구현 클래스에 의존하지말고, 인터페이스에 의존하라는 뜻으로 **역할에 의존하게 해야한다 !!!**  
클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하면 변경이 어려워진다.

자동차 → 스노우타이어 (x)  
자동차 → 타이어 → (스노우타이어, 타이어, 광폭타이어) (o)

## 요약

모든 설계에 역할과 구현을 분리하자!! ex) 자동차, 공연의 예
언제든지 유연하게 변경할 수 있게 만드는것이 좋은 객체지향설계이다.

이상적으로는 모든 설계에 인터페이스를 부여하는 것 but, 단점도 있다

## 참고

[https://devlog-wjdrbs96.tistory.com/380](https://devlog-wjdrbs96.tistory.com/380)
[https://velog.io/@haero_kim/SOLID-원칙-어렵지-않다](https://velog.io/@haero_kim/SOLID-%EC%9B%90%EC%B9%99-%EC%96%B4%EB%A0%B5%EC%A7%80-%EC%95%8A%EB%8B%A4)
[https://www.nextree.co.kr/p6960/](https://www.nextree.co.kr/p6960/)

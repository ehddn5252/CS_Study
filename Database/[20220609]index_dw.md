# 인덱스

작성일: 2022.06.05

학습 목표: 인덱스는 원리에 대해서, 그리고 언제 사용하면 될 지 알면 될 것이다.

인덱스의 필요성
인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다. 예를 들어 책의 마지막장에 있는 찾아보기를 생각해보면 된다.

## B-Tree
인덱스는 보통 B-tree 라는 자료 구조로 이루어져 있다. 이는 루트 노드, 그리고 루트 노드와 리프 노드 사이에 있는 브랜치 노드로 나뉜다.

B-tree 예제
![image](https://user-images.githubusercontent.com/51036842/172034793-af533b65-3873-45b2-84ba-a7982b6111e1.png)

예를 들어 E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라 E가 있을 법한 리프 노드로 들어가서 E를 탐색하면 쉽게 찾을 수 있다. 이 자료 구조 없이 E를 탐색하고자 하면 A, B, C, D, E 다섯 번을 탐색해야 하지만, 이렇게 노드들로 나누면 두 번만에 리프 노드에서 찾을 수 있다.

## 인덱스의 효율적인 이유와 대수확장성
인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다.

대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미합니다.
 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.


| 트리 깊이 | 인덱스 항목의 수|
| ---- |----  |
|3|64|
|4|256|
|5|1,024|
|6|4,096|
|7|16,384|
|8|65,536|
|9|262,144|
|10|1,048,576|


## 인덱스 최적화.

인덱스를 사용할 때는 다음을 생각해봐야 합니다.

1. 먼저 인덱스는 비용이다.
먼저 인덱스는 두 번 탐색하도록 강요합니다. 인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문에, 관련 읽기 비용이 들게 됩니다. 

    또한 컬렉션이 수정되었을 때 인덱스도 수정되어야 합니다. 그리고 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적입니다.

2. 항상 테스팅하라.
인덱스 최적화 기법은 서비스에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이다. 그렇기 때문에 항상 테스팅하는 것이 중요하다. explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.
참고로 MySQL에서는 다음과 같은 코드로 테스팅을 한다.

    ```SQL
    EXPLAIN
    SELECT * FROM t1
    JOIN t2 ON t1.c1 = t2.c1
    ```

3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.

    보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라집니다. 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 합니다.
    1. 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
    2. 정렬에 쓰는 필드라면 그 다음 인덱스로설정한다.
    3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정합니다.
    4. 유니크한 값의 정도를 카디널리티라고 합니다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 합니다. 예를 들어 age와 email이 있다고 해봅시다. 어떤 것이 더 높나요? 당연히 email 입니다. 즉, email이라는 필드에 대한 인덱스를 먼저 생성해야 합니다.